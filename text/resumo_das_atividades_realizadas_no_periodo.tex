Nesta seção são apresentadas as atividades desenvolvidas no período de Maio/2013 a Fevereiro/2015, previstas no plano inicial que foi enviado à FAPESP. Vale ressaltar que, em parte do período deste relatório, o bolsista esteve no exterior realização um estágio sanduíche no \textit{Institut National de Recherche en Informatique et en Automatique} (INRIA) . As atividades realizadas são brevemente descritas nas subseções a seguir.

\subsection{Estágio no Exterior}

O estágio contou com o apoio financeiro da CNPQ (Processo: 241028/2012-4) e foi realizado no \textit{Institut national de recherche en informatique et en automatique} (INRIA), França. O aluno ficou na França por um ano (Abril de 2013 - Abril de 2014) sob a supervisão do professor Doutor Nicolas Anquetil. O grupo de pesquisa é especializado em remodularização e modernização de sistemas orientados a objetos com enfoque em \textit{Model-Driven Development}. 

O vínculo com o CNPQ foi encerrado no mês de Abril e a bolsa da FAPESP foi reatividade. Uma cópia do parecer emitido pelo orientador no exterior pode ser encontrado no Anexo~\ref{anexo:comprovante_nicolas}.

\subsection{Mapeamento Sistemático}

Quando se conduz uma revisão de literatura sem o pré-estabelecimento de um protocolo de revisão há um direcionamento por interesses pessoais, o que leva a resultados pouco confiáveis. Neste contexto, pesquisadores vem utilizando uma técnica denominada de Mapeamento Sistemático (MS) para auxiliar o pesquisador a conduzir um revisão bibliográfica de forma totalmente sistemática com o intuito de evitar que trabalhos importantes fiquem fora de suas pesquisas. Um MS é caracterizada por ser um meio de avaliar e interpretar todas as pesquisas disponíveis, referentes a um questão de pesquisa, tema, área ou fenômeno de interesse. O MS tem como objetivo apresentar uma avaliação justa de um tema de pesquisa, utilizando uma metodologia confiável, rigorosa e auditável~\cite{kit04}.

De acordo com~\citet{kit04} o MS implica na forma mais adequada para se identificar, avaliar e interpretar toda pesquisa importante para um tema em particular. Resume-se que um MS configura um alicerce para novas atividades de pesquisa acerca de determinado tema. Dessa forma, foi realizado um MS sobre \textit{Architecture-Driven Modernization} (ADM) e \textit{Knowledge-Discovery Metamodel} (KDM). A nossa motivação para realizar esse MS é identificar os temas que têm sido mais investigados, bem como os temas que ainda não foram investigados. Embora, a ADM é uma abordagem relativamente nova, OMG afirma que ela é uma importante abordagem pois combina dois dos principais campos da Engenharia de Software, ou seja, \textit{Model-Driven Development} e Engenharia Reversa. Desde a definição da ADM muitos esforços têm enfatizado a modernização de sistemas legados por meio desta abordagem. Neste contexto, é importante realizar uma investigação mais sistemática dos temas englobados por esta área de pesquisa. 

Para atingir este objetivo, foi realizado um MS. Os resultados, bem como o protocolo de pesquisa elaborado, foram publicados no \textit{IEEE Information Reuse and Integration} (IRI 2014) , o qual tem qualis B2. O artigo foi apresentado pelo bolsista em Agosto de 2014 em São Francisco, California. Maiores detalhes sobre esse artigo pode ser obtido no Apêndice A deste relatório. O mesmo anexo contem uma cópia da obra submetida.


\subsection{Estabelecimento do Catalogo de Refatoração para o metamodelo KDM} % (fold)
	 \label{sub:catalogo_kdm}

Foi elaborado um catalogo dedicado para ser aplicado no metamodelo do KDM. Mais especificamente esse catalogo foi adaptado com base em catálogos já disponíveis na literatura. Para a definição desse catalogo de refatoração, foi utilizado um formato inspirado pelo~\cite{refactImpro}. Em outras palavras, o catalogo foi descrito da seguinte forma: (\textit{i}) o nome do refatoração, (\textit{ii}) descrição da típica situação onde a refatoração deve ser aplicada, (\textit{iii}) descrição da solução para solucionar uma determinada situação problemática, (\textit{iv}) pre-condições que devem ser satisfeitas para aplicar a refatoração, (\textit{v}) os parâmetros necessários para executar a refatoração e (\textit{vi}) descrição dos passos para realizar a refatoração.

O catalogo de refatoração é estruturado em quatro grupos como pode ser observado na Tabela~\ref{tab:catalogue}, a qual contêm 17 refatorações. O primeiro grupo chamada \textit{Rename Feature} consiste de refatorações para renomear \textit{ClassUnit}, \textit{StorableUnits} e \textit{MethodUnits}. O segundo grupo, \textit{Moving Features Between Objects} consiste de refatorações simples, tais como mover ou criar características, ou seja, criar ou mover atributos, métodos ou classes. O terceiro grupo,  \textit{Organizing Data}, é responsável por definir um conjunto de refatorações para ser organizar a estrutura do código-fonte. Por fim, o quatro grupo, \textit{Dealing With Generalization}, representa refatorações para mover métodos e/ou atributos sobre uma especifica hierarquia de classes. 

\begin{table}[!h]
\caption{Refactorings Adapted to KDM}
\label{tab:adaptedRefactoring}
\centering
  % Requires \usepackage{graphicx}
  \includegraphics[scale=0.67]{figuras/NovoCatalogue}
\end{table}

Vale ressaltar que um artigo descrevendo o catalogo de refatoração adaptado para o KDM também foi no \textit{IEEE Information Reuse and Integration} (IRI 2014) , o qual tem qualis B2. O artigo foi apresentado pelo bolsista em Agosto de 2014 em São Francisco, California. Além disso, o bolsista participou das sessões técnicas e palestras. Maiores detalhes sobre esse artigo pode ser obtido no Apêndice B deste relatório. O mesmo contem uma cópia da obra submetida.

\subsection{Um ambiente integrado para desenvolvimento e apoio para o catalogo de refatorações do metamodelo KDM}

Durante a revisão sistemática pode-se averiguar que tanto o processo ADM e o seu metamodelo KDM têm sido vastamente utilizado na literatura para auxiliar a modernização de sistemas legados. No entanto, também pode-se verificar qua até o momento não existe nenhum ambiente integrado de desenvolvimento para guiar o engenheiro para automaticamente aplicar as refatorações e modernizações como existe em outros paradigmas, tais como o paradigma orientado a objetos. Para mitigar tal limitação, durante o período de vigência da bolsa foi desenvolvido um \textit{plug-in} utilizando a plataforma do Eclipse. 

Esse \textit{plug-in} fornece um ambiente para realizar as refatorações apresentadas na Seção~\ref{sub:catalogo_kdm} de forma totalmente automatizada. Na Figura~\ref{fig:ferramenta} é ilustrado todo o processo no qual o \textit{plug-in} é baseado. Como pode ser observado nessa figura a utilização do \textit{plug-in} pode ser ilustrada em três passos: (\textit{i}) engenharia reversa (\textit{reverse engineering}), (\textit{ii}) refatorações (\textit{refactorings}) e (\textit{iii}) engenharia avante (\textit{forward engineering}). Maiores detalhes sobre tais passos são descritos nas próximas seções.

\begin{figure}[!h]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/processoDaFerramenta}}

\caption{Passos para utilização do \textit{plug-in}}
 \label{fig:ferramenta}
\end{figure}


 \subsubsection{Engenharia Reversa}

Para iniciar esse passo o engenheiro de software deve entrar com um arquivo que representa uma instância do metamodelo KDM ou um determinado código-fonte para realizar a refatoração. No caso do código-fonte ser a entrada escolhida, o engenheiro de software começa o processo no \textbf{Level-0} escolhendo um projeto no Eclipse\footnote{https://www.eclipse.org/} que contenha o código-fonte para realizar as refatorações. Posteriormente, no \textbf{Level-1} o código-fonte precisa ser transformado para um modelo especifico de plataforma (no inglês - Platform-Specific Model (PSM)). Esse PSM representa uma instância do código-fonte em um nível mais abstrato do código-fonte. Para realizar essa transformação (código-fonte para PSM) foi implementado um extrator de modelo em Java.

Após criar o PSM o próximo level (\textbf{Level-2}) consiste em transformar o PSM para um Modelo Independente de plataforma (no inglês - Platform-Indented Model (PIM)) o qual é baseado no metamodelo do KDM. Nesse level o \textit{plug-in} utiliza o \textit{framework} MoDisco\footnote{http://www.eclipse.org/MoDisco/} para realizar a transformação de PSM para PIM.

Na Figura~\ref{fig:plugin} é apresentado uma visão geral do \textit{plug-in} desenvolvido pelo bolsista durante a período de vigência da bolsa. Apenas para o propósito de explicação, foi identificado quatro principais regiões do \textit{plug-in}, veja Figura\ref{fig:plugin} \textcircled{a}, \textcircled{b}, \textcircled{c} and \textcircled{d}.

\begin{figure}[!h]
 \centering
 \scalebox{0.9}{\includegraphics{figuras/ScreenShot_tool}}
\caption{Visão geral do \textit{plug-in} desenvolvido}
 \label{fig:plugin}
\end{figure}

Como já salientado anteriormente todas as refatorações fornecidas pelo \textit{plug-in} são feitas com base no metamodelo KDM. Dessa forma, para auxiliar o engenheiro de software a realizar as refatorações um menu chamado \textit{Refactoring KDM} foi adicionado, veja Figura~\ref{fig:plugin}\textcircled{a}. Utilizando esse menu o engenheiro de software pode interagir com o metamodelo do KDM e escolher qual refatoração deve ser executada. Note que na região \textcircled{a} da Figura~\ref{fig:plugin} é possível ver todas as 17 refatorações implementadas no \textit{plug-in}.

Na região \textcircled{b} da Figura~\ref{fig:plugin} é apresentado um diagrama de classe. Esse diagrama pode ser utilizado pelo engenheiro de software antes ou depois de aplicar as refatorações no modelo KDM. Usualmente o engenheiro pode utilizar esse diagrama antes de aplicar refatorações para decidir onde deve-se realmente aplicar as refatorações. Além disso, esse diagrama é útil por que geralmente sistemas legados não contêm nenhum tipo de documentação, sendo o código-fonte o único artefato disponível do mesmo. Portanto, criar um diagrama de classe durante a execução de refatorações no sistema legado pode ser uma boa alternativa para melhorar a documentação de um determinado sistema.

O \textit{plug-in} também fornece múltiplas versões de um sistema em nível de modelos, ou seja, em nível de modelos KDM. O objetivo é permitir que o engenheiro de software trabalhe interativamente em vários modelos, permitindo assim que o engenheiro de software escolha e explore diferentes caminhos de refatoração. Como pode ser observado na região  \textcircled{c} da Figura~\ref{fig:plugin}, o engenheiro deve selecionar o arquivo KDM e escolher a opção ``\textit{Versions}''. Três opções são disponíveis nesse menu (\textit{i}) \textit{List of Changes}, (\textit{ii}) \textit{Delete version} and (\textit{iii}) \textit{Create a child version}. A primeira opção mostra todas refatorações que já foram feitas pelo engenheiro (ver região \textcircled{d} ) - a segunda opção é responsável por deletar uma versão - e a ultima opção criar uma cópia do arquivo KDM, permitindo assim que o engenheiro aplique outras refatorações e explore diferentes caminhos de refatoração sem afetar o modelo KDM principal do projeto.


 \subsubsection{Executando Refatorações no \textit{Plug-in}}

Após o engenheiro clicar no menu da região \textcircled{a} (ver Figura~\ref{fig:plugin}) e escolher qual refatoração aplicar um \textit{Wizard} será mostrado. Para explicação, considere que o engenheiro de software escolheu aplicar a refatoração denominada \textit{Extract Class}. Então o engenheiro deve selecionar qual metaclass o mesmo deseja extrair, esse passo é ilustrado na Figura~\ref{fig:wizard} (a). Posteriormente o \textit{plug-in} executa o \textit{Wizard} como ilustrado na Figura~\ref{fig:wizard} (b). Como pode ser observado, aqui o engenheiro de software pode atribuir um nome para a nova metaclasse. Além disso, uma prévia de todos os detectados \textit{StorableUnits} e \textit{MethodUnis} que podem ser extraídos e adicionados na outra classe também são mostrados. O engenheiro pode também selecionar se a nova classe será uma classe interna ou uma classe normal. Também é possível especificar se métodos assessores (\textit{getters} e \textit{setters}) devem ser criados ou não. 

\begin{figure}[!h]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/Wizard2}}
\caption{Extract Class Wizard}
 \label{fig:wizard}
\end{figure}

Após o engenheiro preencher todos os campos necessários, ele pode clicar no botão \textit{Finish} e então a refatoração \textit{Extract Class} é executada. Como pode ser observado na Figura~\ref{fig:wizard} (c) uma nova instância de \textit{ClassUnit} denominada \textit{Document} foi criada - dois \textit{StorableUnits} da metaclasse \textit{Pessoa}, ``rg'' e ``CPF'' foram movidas para \textit{Document}.


 \subsubsection{Engenharia Avante}

Após o engenheiro realizar todas as refatorações no KDM os próximos passos são: (\textit{i}) transformar o KDM para um PSM e (\textit{ii}) transformar o PSM para artefatos físicos (código-fonte). O primeiro passo é executado baseado em um conjunto de transformações utilizando a linguagem ATL Transformation Languag (ATL)\footnote{https://www.eclipse.org/atl/}. O último passo consiste em utilizar \textit{templates} para gerar o código-fonte refatorado.  Na Figura~\ref{fig:forward} é apresentado como é feita a geração de código-fonte.

\begin{figure}[!h]
 \centering
 \scalebox{0.4}{\includegraphics{figuras/ForwardEngineering}}
\caption{Passos da Engenharia Avante}
 \label{fig:forward}
\end{figure}

 \subsubsection{Arquitetura do \textit{plugin}}

Na Figura~\ref{fig:architecture} é ilustrado a arquitetura do \textit{plug-in} desenvolvido durante o período de vigência da bolsa. Como pode ser observado nessa figura, a primeira camada (\textit{layer}) é o \textit{Core Framework}. Essa camada representa que o \textit{plug-in} foi desenvolvida utilizando como base a plataforma de desenvolvimento Eclipse. Além disso, nessa camada pode-se observar que também foi utilizado Java e Groovy como linguagem de programação. Também é possível identificar que nessa camada alguns \textit{plug-ins} da plataforma de desenvolvimento Eclipse foram utilizados, tais como MoDisco\footnote{http://www.eclipse.org/MoDisco/} e EMF\footnote{https://www.eclipse.org/modeling/emf/}. Modisco e EMF ambos foram utilizados pois fornecem uma \textit{Application Programming Interface} (API) para facilitar o acesso ao metamodelo KDM.

\begin{figure}[!h]
 \centering
 \scalebox{0.8}{\includegraphics{figuras/Arquitetura}}
\caption{Arquitetura do \textit{plug-in}}
 \label{fig:architecture}
\end{figure}

A segunda camada, \textit{Tool Core}, é onde todas as refatorações fornecidas pelo \textit{plug-in} foram implementadas. A ultima camada é onde a interface gráfica do \textit{plug-in} foi desenvolvida. Vale ressaltar que um artigo sobre esse \textit{plugin} foi publicado no  2nd \textit{Workshop on Software Visualization, Evolution and Maintenance} (VEM). O bolsista esteve presente nesse evento, apresentado o artigo e participando das sessões técnicas e palestras. Mais detalhes sobre este \textit{plugin} podem ser encontrados na cópia desse artigo no Apêndice C.

\subsection{Um Metamodelo para Especificar Refatorações para o KDM - (\textit{Refac-KDM})}

Durante o desenvolvimento e evolução de software novas funcionalidades geralmente são adicionadas ou são ajustadas a novas exigências. Devido a tais alterações, a flexibilidade da arquitetura desse sistema pode ser um fator desafiador. Em outros casos, após aplicar um conjunto de alterações a arquitetura continua perfeitamente adequada. Porém, usualmente é necessário aplicar mudanças na arquitetura desse sistema para confortar tais alterações. 

Para melhorar o projeto de um determinado software, geralmente os engenheiros de software gastam uma quantidade significativa de tempo reestruturando o software manualmente. No entanto, reestruturar código manualmente além de ser uma tarefa que demanda tempo é totalmente propicia a erros. Não importa a atenção dispendida pelo engenheiro de software durante a atividade de reestruturação, se o sistema é relativamente grande, há uma boa chance de que o mesmo irá ter o seu comportamento alterado após tal atividade. Como ressaltado anteriormente é de suma importância que o comportamento do sistema seja preservado após a reestruturação, assim, o conceito de refatoração deve ser aplicado (ver Seção~\ref{sub:refatoracao}).

 Hoje em dia refatoração é utilizada tanto no âmbito acadêmico quanto na industria. Refatoração é uma área muito madura e muito difundida. Além disso, várias IDEs executam facilmente e de forma segura um conjunto refatorações para um vasto número de linguagens de programação. Com o surgimento de MDD é importante que os conceitos de refatorações sejam adaptados tanto para MDRE (ver Seção~\ref{sec:model_driven_reverse_engineering}) e ADM. Uma iniciativa têm sido conduzida pelo outorgado. Mais especificadamente o bolsista definiu um ambiente integrado para desenvolvimento e apoio para o catalogo de refatorações do metamodelo KDM~\citep{KDM_RE_A_Model_Driven_Refactoring_Tool_for_KDM}. Maiores informações podem ser obtidas no artigo publicado, o mesmo pode ser visualizado na integra no Apêndice X.

Um olhar mais atento à reutilização de refatorações levanta a questão sobre o que pode ser reutilizado e o que não pode. Trabalhos anteriores nesta área tem mostrado que há potencial para reutilização, mas é limitado, de uma forma ou de outra. No entanto, pesquisas também apontam que algumas características não podem ser capturadas na parte reutilizável de uma refatoração. Por exemplo, uma refatoração genérica não pode fazer suposições sobre a semântica de uma linguagem de programação. 

Embora a ADM e, principalmente o KDM, tenham sido propostos para apoiar a modernização de sistemas legados, até o momento não existem propostas de um metamodelo para especificar refatorações para o KDM. Portanto, os engenheiros de modernização precisam desenvolver suas próprias soluções para transformar instâncias KDM origem em alvo. Durante o mapeamento sistemático conduzido e publicado pelo outorgado~\citep{iri_systematic_mapping_ADM_2014} (ver Apêndice X) pôde-se observar na literatura a carência de estudos que definem um metamodelo para especificar refatorações para KDM. Sem a adequada representação de refatorações no KDM, a realização de uma refatoração pode se tornar propensa a erros. Assim, é de suma importância definir uma extensão para o KDM em que os engenheiros de modernização possam especificar refatorações independentes de plataforma.

\begin{figure}[!h]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/ProcessoDoMetamodelo_COm_tudo}}
\caption{Princípios e critérios utilizados para criar o metamodelo de refatoração para o KDM}
 \label{fig:processoDOMETAMODELO}
\end{figure}

Como já ressaltado existe uma forte necessidade de reutilizar refatorações no contexto da ADM e, principalmente para o metamodelo KDM. Para permitir tal reutilização, as partes de refatorações que podem ser generalizadas devem ser separadas das que são específicas. Por exemplo, considere a refatoração \textit{RenameElement}. As etapas necessárias para executar tal refatoração são iguais, não importa que tipo de elemento precisa ser renomeado. Por exemplo, depois de alterar o valor de um atributo do tipo \textit{String}, todas as referências daquele elemento precisa também ser atualizado. O atributo concreto pode variar dependendo da linguagem de programação, mas o procedimento é o mesmo.	

Com base no exemplo anterior é possível identificar algumas idéias iniciais. Na parte superior da Figura~\ref{fig:processoDOMETAMODELO} são ilustrados os principais conceitos que foram utilizados para criar o metamodelo de refatoração para o KDM. Em primeiro lugar, as partes estruturais de uma refatoração (classes, métodos, atributos, etc), ou seja, os elementos que são transformados, foram considerados bons candidatos para o reuso (ver Figura~\ref{fig:processoDOMETAMODELO} \ding{182}) e assim utilizados como base para a criação do metamodelo de refatoração. Em segundo lugar, foi possível identificar na literatura pesquisas que executam uma refatoração utilizando um conjunto de composições de transformações por meio de linguagens de transformações, tais como OCL e ATL (ver Figura~\ref{fig:processoDOMETAMODELO} \ding{183}). Além disso, também foi constatado que a grande maioria das refatorações são realizadas utilizando operações primárias, tais como: \textit{add}, \textit{remove}, \textit{move}, \textit{create}, entre outras. Tais operações primárias também foram incluídas no metamodelo de refatoração para o KDM (ver Figura~\ref{fig:processoDOMETAMODELO} \ding{184}). Assim, os engenheiros de modernização podem realizar um \textit{chain of primary operations} permitindo a especificar/criar novas refatorações. O catalogo de refatoração proposto por Fowler~\citep{refactImpro} também foi considerado durante a criação do metamodelo de refatoração para o KDM como pode ser observado na Figura~\ref{fig:processoDOMETAMODELO} \ding{185}.




\FloatBarrier

\begin{figure}[h]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/metamodelo7}}
\caption{Metamodel de Refatoração para o KDM}
 \label{fig:METAMODELO}
\end{figure}
\FloatBarrier
Para reutilizar a parte estrutural de uma refatoração, um modelo que represente essa estrutura é necessário. Para o exemplo \textit{RenameElement}, a estrutura basicamente consiste de uma \textit{metaclass} em um \textit{metamodel}. Outras refatorações, tais como \textit{ExtractClass} possuem restrições estruturais mais complexas, como a exigência de que a classe que será extraída esteja contida em um \textit{container object}. O metamodelo de refatorações para o KDM foi definido utilizado EMF (ver Figura~\ref{fig:processoDOMETAMODELO} \ding{186}). O metamodelo propriamente dito, Refac-KDM, pode ser visualizado na Figura~\ref{fig:METAMODELO}. As \textit{metaclasses} que compõem o metamodelo de refatoração, ou seja, Refac-KDM são definidas da seguinte forma:
 
\begin{itemize}

\item \textit{Refactoring} é o elemento raiz utilizado para armazenar todas as informações sobre as refatorações.

\item \textit{RenameFeature} corresponde às categorias de refatorações relacionadas a ação de renomear.\textit{RenameFeature} também armazena todas as refatorações relacionadas com a ação de renomear utilizando o \textit{metaattribute} \textit{allRefactorings}.

\item \textit{RenameClass} representa uma instância da refatoração \textit{rename Class}.  A semântica para a utilização da \textit{RenameClass} consiste em: (\textit{i}) especificar uma \textit{ClassUnit} (\textit{classToBeRenamed}), (\textit{ii}) bem como uma \textit{string} que representa o novo nome (\textit{newName}) da \textit{ClassUnit} após a aplicação da refatoração \textit{renameClassUnit}.

\item \textit{RenameAttribute} representa uma instância da refatoração \textit{rename Attribute}. A semântica para a utilização da \textit{metaclass} \textit{RenameAttribute} consiste em: (\textit{i}) especificar a \textit{ClassUnit} (\textit{sourceClass}) que armazena todos os atributos e todos os métodos, (\textit{ii}) o atributo que será renomeado (\textit{attToBeRename}) e (\textit{iii}) uma \textit{string} que representa o novo nome (\textit{newName}) do atributo após a aplicação da refatoração \textit{renameAttribute}.

\item \textit{RenameMethod} representa uma instância da refatoração \textit{rename Method}. A semântica para a utilização da \textit{metaclass} \textit{RenameMethod} consiste em: (\textit{i}) especificar a \textit{ClassUnit} (\textit{sourceClass}) que armazena todos os atributos e todos os métodos, (\textit{ii}) o método que será renomeado (\textit{methToBeRename}) e (\textit{iii}) uma \textit{string} que representa o novo nome (\textit{newName}) do método após a aplicação da refatoração \textit{renameMethod}.

\item \textit{MovingFeatureBetweenObjects} corresponde às categorias de refatorações relacionadas a ação de movimentar características entre objetos.

\item \textit{MoveAttribute} representa uma instância da refatoração \textit{move field}. A semântica para a utilização da \textit{metaclass} \textit{MoveAttribute} consiste em: (\textit{i}) especificar a \textit{ClassUnit} (\textit{sourceClass}) que armazena todos os atributos e todos os métodos, (\textit{ii}) a \textit{ClassUnit} (\textit{targetClass}) que irá receber o atributo a ser movido, (\textit{iii}) e o atributo que será movimentado (\textit{attrToMove}).  

\item \textit{MoveMethod} representa uma instância da refatoração \textit{move method}. A semântica para a utilização da \textit{metaclass} \textit{MoveMethod} consiste em: (\textit{i}) especificar a \textit{ClassUnit} (\textit{sourceClass}) que armazena todos os atributos e todos os métodos, (\textit{ii}) a \textit{ClassUnit} (\textit{targetClass}) que irá receber o método a ser movido, (\textit{iii}) e o método que será movimentado (\textit{methToMove}).

\item \textit{ExtractClass} representa uma instância da refatoração \textit{extract class}. A semântica para a utilização da \textit{metaclass} \textit{ExtractClass} consiste em especificar em: (\textit{i}) a \textit{ClassUnit} (\textit{sourceClass}) que armazena todos os atributos e todos os métodos, (\textit{ii}) uma lista de atributos (\textit{attrsToBeExtracted}) e uma lista de métodos (\textit{methsToBeExtracted}) para serem extraídos, (\textit{iii}) uma \textit{string} que representa o nome (\textit{newName}) da classe que foi extraída, (\textit{iv}) bem como um \textit{Package} (\textit{targetPackage}) que irá receber a classe criada após a execução da refatoração.

\item \textbf{TERMINAR AQUI TODAS AS METACLASSES}

\end{itemize} 

\subsubsection{Uma DSL para auxiliar a instânciação de refatorações com base no Refac-KDM}\label{sec:DSL}

A fim de utilizar plenamente as vantagens das refatorações, os desenvolvedores precisam ter um bom conhecimento de linguagem de programação avançada. Na verdade os desenvolvedores devem estar familiarizados como as semânticas das refatorações (por exemplo, qual(is) é (são) o(s) pré-requisito(s) para a execução de uma refatoração) e como/onde utilizar programar tais refatorações. A instanciação de uma refatoração utilizando o Refac-KDM é bastante verbosa, complexa e propensa a erros, uma vez que exige conhecimento avançadas de refatoração e habilidades avançadas de programação em relação a API Ecore. Com o objetivo de diminuir a quantidade de código-fonte, esforço e competência necessários para instanciar refatorações utilizando o Refac-KDM, foi desenvolvido uma linguagem especifica de domínio (do inglês, \textit{Domain-Specific Language} - DSL) que auxilia a instanciação de refatorações sistematicamente. Na parte inferior a esquerda da Figura~\ref{fig:processoDOMETAMODELO} é possível visualizar um exemplo da sintaxe da DSL criada para auxiliar a instanciação do metamodelo Refac-KDM.

A DSL para auxiliar a instanciação do Refac-KDM foi desenvolvida utilizando Xtext~\ref{sec:apoio_ferramental}\footnote{\texttt{https://www.eclipse.org/Xtext/}}. Xtext é um \textit{framework} do Eclipse\footnote{\texttt{https://www.eclipse.org}} que facilita a definição de gramática\footnote{Gramáticas representam a definição formal de um sintaxe textual concreta. Consistem em um conjunto de regras de produção para definir como o \textit{textual input} (, i.e., sentenças) são representadas. Basicamente, as regras de produção podem ser representadas utilizando \textit{Backus–Naur Form} (BNF), por exemplo, \textit{S ::= P1 ... Pn}, essa gramática define um símbolo \textit{S} por um conjunto de expressões \textit{P1 ... Pn}.} 
com a utilização de um metamodelo que foi definido utilizando EMF. Xtext tem como principal objetivo automatizar e agilizar o processo de desenvolvimento de DSLs.

 Em Xtext a gramática para especificar DSLs segue uma notação similar ao \textit{Backus–Naur Form} (BNF) chamada de regras do \textit{parser}. Tais regras representam a sintaxe concreta da DSL. Note que para facilitar o entendimento da DSL, trechos da mesma são mostradas em listagens de códigos separados, bem como símbolos para explanar o propósito de uma terminada linha da gramática. Na Listagem de código~\ref{lst:dsl_part_1} é ilustrado o primeiro trecho da gramática da DSL. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle={\scriptsize}, mathescape=true, label={lst:dsl_part_1}, caption={Gramática da DSL - parte 1}]
	
$\textrm{\ding{182}}$ grammar com.br.refactoring.xtext.RefacKdm with org.eclipse.xtext.common.Terminals 
$\textrm{\ding{183}}$ import ``platform:/resource/com.br.refactoring.RefacKdm/model/RefacKdm.ecore'
$\textrm{\ding{184}}$ import ``http://www.eclipse.org/emf/2002/Ecore'' as ecore
Model: 
	$\textrm{\ding{185}}$ `model' name=ID
	$\textrm{\ding{186}}$ (imports+=Import)$^{*}$
	$\textrm{\ding{187}}$ (contains+=Type)$^{*}$;
\end{lstlisting}

A gramática começa com a definição do nome da DSL (RefacKdm) (ver Listagem de código~\ref{lst:dsl_part_1} \ding{182}). Em sequência é definido os metamodelos que devem ser importados para serem utilizados durante a criação da DSL, ou seja, o metamodelo RefacKdm\ding{183}  e o Ecore\ding{184}.

Em seguida é criado a primeira regra. Essa regra começa com a definição da \textit{metaclass} \texttt{Model}, o corpo da regra começa após os \texttt{:}. Primeiramente para o entendimento da regra, é importante destacar que literais de \textit{string} (que em Xtext podem ser expressas com aspas simples ou duplas) definem palavras-chave da DSL. Como pode ser observado na Listagem de código~\ref{lst:dsl_part_1} é esperado a palavra-chave \texttt{model}\ding{185} seguido por um \texttt{ID}. A gramática que rege o objeto \texttt{ID} é definida como uma sequência ilimitada de maiúsculas e minúsculas, números e o carácter de sublinhado, embora possa não começa por um dígito. A gramática que representa o nó \texttt{ID}\ding{182} pode ser visualizada na Listagem de código~\ref{lst:dsl_part_2}. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_2}, caption={Gramática da DSL - parte 2}]
	$\textrm{\ding{182}}$ terminal ID: (`a'..`z' | `A'..`Z'|`_')(`a'..`z' | `A'..`Z'|`_'|`0'..`9')*;
\end{lstlisting}

Ainda na Listagem de código~\ref{lst:dsl_part_1}  a expressão \texttt{(imports+=Import)$^{*}$}\ding{186} especifica que pode-se instanciar várias instancias da \textit{metaclass} \texttt{Import}. O operador estrela, \texttt{*}, ilustra que o número de elementos (nesse caso \texttt{Import}) é arbitrário; em particular, ele pode ser qualquer número \texttt{>=} 0. Operador \texttt{+=} por sua vez representa que a propriedade \texttt{imports} será uma lista do tipo \texttt{Import}. A expressão \texttt{(contains+=Type)$^{*}$}\ding{187} descrita na Listagem de código~\ref{lst:dsl_part_1} especifica que pode-se instanciar várias instâncias da \textit{metaclass} \texttt{Type}.

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_3}, caption={Gramática da DSL - parte 3}]
Type: 
	$\textrm{\ding{182}}$ Refactoring | FormalizedDefinition;
Refactoring: 
	$\textrm{\ding{183}}$ (RenameFeature | MovingFeaturesBetweenObjects 
		$\textrm{\ding{229}}$ | OrganizingData | DealingWithGeneralization | PrimaryOperation);
\end{lstlisting}

A definição da \textit{metaclass} \texttt{Type} é interessante, uma vez que \texttt{Type} representa uma \textit{metaclass} abstrata com dois subtipos, como pode ser observado na Listagem de código~\ref{lst:dsl_part_3}. Ainda nessa listagem, é possível observar que o operador, \texttt{|}, é utilizado para expressar alternativas \ding{182}, o que é traduzido para o conceito de herança no metamodelo do Refac-KDM. A definição da \textit{metaclass} \texttt{Refactoring} é ilustrada por um conjunto de \textit{submetaclass} \ding{183} que são expressas na gramática da DSL pelo operador, \texttt{|}, a saber: \texttt{RenameFeature}, \texttt{MovingFeaturesBetweenObjects}, \texttt{OrganizingData}, \texttt{DealingWithGeneralization} and \texttt{Create}.

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_4}, caption={Gramática da DSL - parte 4}]
RenameFeature: 
	$\textrm{\ding{182}}$ `Rename_Feature' name = ID `{'
	 	$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ (allRefactorings+=RenameClass)$^{*}$
	 	$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ (allRefactorings+=RenameAttribute)$^{*}$
	 	$\textrm{\ding{229}}$ $\textrm{\ding{185}}$ (allRefactorings+=RenameMethod)$^{*}$
   `}';
\end{lstlisting}

A definição da \textit{metaclass} \texttt{RenameFeature} é ilustrada na Listagem de código~\ref{lst:dsl_part_4}. Como pode ser observado essa regra começa com a definição da palavra-chave \texttt{Rename\_Feature} seguida por um \texttt{ID} \ding{182}. As expressões descritas em \ding{183}, \ding{184} e \ding{185} representam que pode haver qualquer número de instancias das \textit{metaclasses} \texttt{RenameClass}, \texttt{RenameAttribute} e \texttt{RenameMethod}, respectivamente. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_5}, caption={Gramática da DSL - parte 5}]
RenameClass: 
	$\textrm{\ding{182}}$ `Refactoring_RenameClass' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ `classToBeRenamed' `:' classToBeRenamed = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ `newName' `:' newName = ID
	`}';
RenameAttribute: 
	`Refactiong_RenameAttribute' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' ':' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{185}}$ `attributeToBeRenamed' `:' attributeToBeRenamed = [StorableUnit]
		$\textrm{\ding{229}}$ `newName' `:' newName = ID
	`}';
RenameMethod: 
	`Refactoring_RenameMethod' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{186}}$ `methodToBeRenamed' `:' methodToBeRenamed = [MethodUnit]
		$\textrm{\ding{229}}$ `newName' `:' newName = ID
	`}';
\end{lstlisting}

A definição da \textit{metaclass} \texttt{RenameClass} é ilustrada na Listagem de código~\ref{lst:dsl_part_5}. A regra começa com a definição da palavra-chave \texttt{Refactoring\_RenameClass} seguida por um \texttt{ID} e a chave, \texttt{\{} \ding{182}. Essa chave representa o inicio do escopo relacionado a refatoração \textit{Rename Class}, ou seja, é um contexto delimitante aos quais valores e expressões estão associados a refatoração. Em seguida a palavra-chave \texttt{classToBeRenamed} é esperada, seguido por \texttt{:} \ding{183}. Posteriormente uma instância da \texttt{ClassUnit} que será renomeada deve ser atribuída. Em Xtext, a notação \texttt{classToBeRenamed = [ClassUnit]} indica que é espero uma instância da \textit{metaclass} \texttt{ClassUnit}, e não apenas um nome. Em seguida a palavra-chave \texttt{newName} é esperado, seguido por \texttt{:}, finalmente o novo nome da classe deve ser especificado \ding{184}.

A gramática que define a semântica da refatoração \textit{rename attribute} é similar a anterior. Como visualizado na Listagem de código~\ref{lst:dsl_part_5} \ding{185}, a única diferença é que deve-se atribuir uma instância da \textit{metaclass} \texttt{StorableUnit}, ou seja, o atributo que almeja-se renomear.  A semântica da refatoração \textit{rename method} é praticamente a mesma que a refatoração \textit{rename attribute}. A única diferença é que deve-se atribuir uma instância da \textit{metaclass} \texttt{MethodUnit} \ding{186}. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_6}, caption={Gramática da DSL - parte 6}]
MovingFeaturesBetweenObjects: 
	$\textrm{\ding{182}}$ `MovingFeaturesBetweenObjects' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ (allRefactorings+=MoveAttribute)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ (allRefactorings+=MoveMethod)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{185}}$ (allRefactorings+=ExtractClass)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{186}}$ (allRefactorings+=InlineClass)$^{*}$
	`}';
\end{lstlisting}

A definição da \textit{metaclass} \texttt{MovingFeaturesBetweenObjects} é ilustrada na Listagem de código~\ref{lst:dsl_part_6}. Perceba que tal definição é similar a da \textit{metaclass} \texttt{RenameFeature} (ver Listagem de código~\ref{lst:dsl_part_4}). Como pode ser observado a regra começa com a definição da palavra-chave \texttt{MovingFeaturesBetweenObjects} seguida por um \texttt{ID} \ding{182}. As expressões descritas em \ding{183}, \ding{184}, \ding{185} e \ding{186} representam que pode haver qualquer número de instancias das \textit{metaclasses} \texttt{MoveAttribute}, \texttt{MoveMethod}, \texttt{ExtractClass} e \texttt{InlineClass}, respectivamente. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_7}, caption={Gramática da DSL - parte 7}]
MoveAttribute: 
	$\textrm{\ding{182}}$ `Refactoring_MoveAttribute' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ `targetClass' `:' targetClass = [ClassUnit]
		$\textrm{\ding{229}}$ `attributeToBeMoved' `:' attributeToBeMoved = [StorableUnit]
	`}';
MoveMethod:
	`Refactoring_MoveMethod' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ `targetClass' `:' targetClass = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ `methodToBeMoved' `:' methodToBeMoved = [MethodUnit]
	`}';
ExtractClass: 
	`Refactoring_ExtractClass' name = ID `{'
		$\textrm{\ding{229}}$`sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ `attribute(s)ToBeMoved' `:' 
			$\textrm{\ding{229}}$ '{`attributesToBeMoved += [StorableUnit] 
				$\textrm{\ding{229}}$ (`,'(attributesToBeMoved += [StorableUnit]))*`}'
		$\textrm{\ding{229}}$ $\textrm{\ding{185}}$ `nameToTheNewClass' `:' newName = ID
	`}';
InlineClass: 
	`Refactoring_InlineClass' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{186}}$ `classToGetAllFeatures' `:' classToGetAllFeatures = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{187}}$ `classToRemove' `:' classToRemove = [ClassUnit]
	`}';
\end{lstlisting}

A semântica da refatoração \textit{move attribute} é definido na gramática da Listagem de código~\ref{lst:dsl_part_7} \ding{182}. Como pode ser observado é esperado a palavra-chave \texttt{Refactoring\_MoveAttribute} seguida por um \texttt{ID} e \texttt{\{}. Posteriormente deve-se especificar a palavra-chave \texttt{sourceClass}, seguido por \texttt{:}. Uma instância da \texttt{ClassUnit} que contém o atributo que será movimentado deve ser atribuída. Em seguida, deve-se indicar a \texttt{targetClass}. Novamente, uma instância de \textit{ClassUnit} deve ser atribuída, ou seja, a classe que receberá o atributo. Por fim, deve-se especificar qual atributo realmente será movimentado. Assim, a palavra-chave \texttt{attributeToBeMoved} deve ser especificada, seguido por \texttt{:}. Uma instância de \texttt{StorableUnit} que representa o atributo que será movimentado deve ser atribuída.

A regra que descreve a refatoração \texttt{move method} é similar a refatoração \textit{move attribute} como pode ser observado na Listagem de código~\ref{lst:dsl_part_7}, duas principais diferenças podem ser notadas. A primeira diferença é a primeira palavra-chave da regra \texttt{Refactoring\_MoveMethod}. A segunda diferença pode ser ser observado na expressão \texttt{methodToBeMoved = [MethodUnit]} \ding{183}. Essa expressão mostra que deve-se especificar o método que será movimentado.

A refatoração \textit{extract class} é definida na sequência. A regra sempre começa com a palavra-chave \texttt{Refactoring\_ExtractClass} seguida por um \texttt{ID} e \texttt{\{}. Similarmente, também deve-se especificar a palavra-chave \texttt{sourceClass} seguido por \texttt{:}. Uma instância da \texttt{ClassUnit} que contém os atributos que serão extraídos deve ser especificada. A diferença pode ser observado na expressão ilustrada pelo símbolo \ding{184}. Essa expressão inicia-se com a palavra-chave \texttt{attribute(s)ToBeMoved} seguido por \texttt{:} e \texttt{\{}, nesse contexto as chaves representam o(s) atributo(s) que será(ão) extraído(s). Em seguida a expressão descreve que ao menos uma instância de \texttt{StorableUnit} deve ser atribuída, porém, pode-se especificar mais do que uma instância de \texttt{StorableUnit}  para ser extraído, simplesmente separando cada \texttt{StorableUnit} por virgula (\texttt{,}). Em seguida, a palavra-chave \texttt{nameToTheNewClass} deve ser especifica seguido por \texttt{:} e \texttt{ID}.

Para satisfazer a semântica da gramática relacionada a refatoração \textit{inline class} deve-se primeiramente especificar a palavra-chave \texttt{Refactoring\_InlineClass} seguida por um \texttt{ID} e \texttt{\{}. Em seguida, deve-se especificar a palavra-chave \texttt{classToGetAllFeatures} e \texttt{:} (ver \ding{186}). Uma instância de uma \texttt{ClassUnit} deve ser atribuída. Finalmente, deve-se especificar a palavra-chave \texttt{classToRemove}, \texttt{:} e uma instância de \texttt{ClassUnit} que representa a classe que será removida (ver \ding{186}).

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_8}, caption={Gramática da DSL - parte 8}]
OrganizingData: 
	$\textrm{\ding{182}}$ `OrganizingData' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ (allRefactorings+=ReplaceDataValueWithObject)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ (allRefactorings+=EncapsulateField)$^{*}$
	`}';
\end{lstlisting}
  
A definição da \textit{metaclass} \texttt{OrganizingData} é ilustrada na Listagem de código~\ref{lst:dsl_part_8}. Note que a  regra começa com a definição da palavra-chave \texttt{OrganizingData} seguida por um \texttt{ID} \ding{182}. As expressões descritas em \ding{183} e \ding{184} representam que pode haver qualquer número de instancias das \textit{metaclasses} \texttt{ReplaceDataValueWithObject} e \texttt{EncapsulateField}, respectivamente. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_9}, caption={Gramática da DSL - parte 9}]
ReplaceDataValueWithObject: 
	`Refactoring_ReplaceDataValueWithObject' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{182}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ `attributeToReplaceDataWithObject' `:' 
			$\textrm{\ding{229}}$ attributeToReplaceDataWithObject = [StorableUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ `newAttributes' `:' `{'
			$\textrm{\ding{229}}$ (newAttributes+=StorableUnit)$^{*}$
		`}'
	`}';
EncapsulateField: 
	`Refactoring_EncapsulateField' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{185}}$` sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ $\textrm{\ding{186}}$ `attributeToEncapsulate' `:' attributeToEncapsulate = [StorableUnit]
	'}';
\end{lstlisting}

A semântica da refatoração \textit{replace data value with object} é definido na gramática da Listagem de código~\ref{lst:dsl_part_9}. Note que é esperado a palavra-chave \texttt{Refactoring\_ReplaceDataValueWithObject} seguida por um \texttt{ID} e \texttt{\{}. Posteriormente deve-se especificar a palavra-chave \texttt{sourceClass}, \texttt{:} e uma instância da \texttt{ClassUnit} deve ser atribuída (ver \ding{182}). Em seguida, deve-se especificar a palavra-chave \texttt{attributeToReplaceDataWithObject},  \texttt{:} e uma instância de \textit{StorableUnit} também deve ser atribuído (ver \ding{183}). Por fim, deve-se especificar a palavra-chave \texttt{newAttributes}, \texttt{:} seguida por um conjunto \texttt{StorableUnit} (ver \ding{184}).

A refatoração \textit{ encapsulate field} é definida na sequência. A regra sempre começa com a palavra-chave \texttt{Refactoring\_EncapsulateField} seguida por um \texttt{ID} e \texttt{\{}. Similarmente, também deve-se especificar a palavra-chave \texttt{sourceClass} seguido por \texttt{:} e uma instância de \texttt{ClassUnit} (ver \ding{185}). Em seguida, deve-se especificar a palavra-chave \texttt{attributeToEncapsulate},  \texttt{:} e uma instância de \textit{StorableUnit}, o qual será encapsulado (ver \ding{186}).

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_10}, caption={Gramática da DSL - parte 10}]
DealingWithGeneralization: 
	$\textrm{\ding{182}}$ `DealingWithGeneralization' name = ID `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ (allRefactorings+=PushDownAttribute)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ (allRefactorings+=PushDownMethod)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{185}}$ (allRefactorings+=PullUpAttribute)$^{*}$
		$\textrm{\ding{229}}$ $\textrm{\ding{186}}$ (allRefactorings+=PullUpMethod)$^{*}$
	`}';
\end{lstlisting}

A definição da \textit{metaclass} \texttt{DealingWithGeneralization} é ilustrada na Listagem de código~\ref{lst:dsl_part_10}. Note que a regra começa com a definição da palavra-chave \texttt{DealingWithGeneralization} seguida por um \texttt{ID} e a chave, \texttt{\{} \ding{182}. As expressões descritas em \ding{183}, \ding{184}, \ding{185} e \ding{186} representam que pode haver qualquer número de instancias das \textit{metaclasses} \texttt{PushDownAttribute}, \texttt{PushDownMethod}, \texttt{PullUpAttribute} e \texttt{PullUpMethod}, respectivamente.

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_11}, caption={Gramática da DSL - parte 11}]
PushDownAttribute: 
	`Refactoring_PushDownAttribute' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ `attributeToPushDown' `:' attributeToBePushed = [StorableUnit]
		$\textrm{\ding{229}}$ `targetClass' `:' targetClass = [ClassUnit] '}';
PushDownMethod: 
	`Refactoring_PushDownMethod' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ `methodToPushDown' `:' methodToBePushed = [MethodUnit]
		$\textrm{\ding{229}}$ `targetClass' `:' targetClass = [ClassUnit] '}';
PullUpAttribute: 
	`Refactoring_PullUpAttribute' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ `attributeToPullUp' `:' attributeToBePulled = [StorableUnit]
		$\textrm{\ding{229}}$ `targetClass' `:' targetClass = [ClassUnit] '}';
PullUpMethod: 
	`Refactoring_PullUpMethod' name = ID `{'
		$\textrm{\ding{229}}$ `sourceClass' `:' sourceClass = [ClassUnit]
		$\textrm{\ding{229}}$ `methodToPullUp' `:' methodToBePulled = [MethodUnit]
		$\textrm{\ding{229}}$ `targetClass' `:' targetClass = [ClassUnit] '}';
\end{lstlisting} 

As regras que definem a semântica das \textit{metaclasses} \texttt{PushDownAttribute}, \texttt{PushDownMethod}, \texttt{PullUpAttribute} e \texttt{PullUpMethod} estão definidas na Listagem de código~\ref{lst:dsl_part_11}.

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_12}, caption={Gramática da DSL - parte 12}]
$\textrm{\ding{182}}$ PrimaryOperation:
	(CreateClass | CreateAttribute | CreateMethod | 
		$\textrm{\ding{229}}$ RemoveClass | RemoveAttribute | RemoveMethod | 
			$\textrm{\ding{229}}$ MoveClass | CreateInheritance)
;
CreateClass: 
	`Refactoring_CreateClass' `{'
		$\textrm{\ding{229}}$ $\textrm{\ding{183}}$ `package' `:' package = [Package]
		$\textrm{\ding{229}}$ $\textrm{\ding{184}}$ `class' `:' name = ID
	`}';
CreateAttribute: 
	`Refactoring_CreateAttribute' `{'
		$\textrm{\ding{229}}$ `class' `:'className = ID
		$\textrm{\ding{229}}$ `@' attribute = ID 
	`}';
\end{lstlisting}

A definição da \textit{metaclass} \texttt{PrimaryOperation} é ilustrada na Listagem de código~\ref{lst:dsl_part_12} \ding{182}. Essa \textit{metaclass} é responsável por representar algumas das operações básicas que podem constituir uma refatoração (\textit{add}, \textit{remove}, \textit{move}, \textit{create}). Na Listagem de código~\ref{lst:dsl_part_12} apenas algumas dessas operações são destacadas. A operação \textit{create class} é destacado na Listagem de código~\ref{lst:dsl_part_12} \ding{183}, perceba que a regra começa com a definição da palavra-chave \texttt{Refactoring\_CreateClass} seguida pela outra palavra-chave \texttt{package} e \texttt{:}. Em sequência a palavra-chave \texttt{class} e \texttt{:} devem ser especificadas (ver \ding{184}). A operação \textit{create attribute} é similar a anterior. 

\begin{lstlisting}[language=Xtext, frame=single, basicstyle=\scriptsize, mathescape=true, label={lst:dsl_part_13}, caption={Gramática da DSL - parte 13}]
$\textrm{\ding{182}}$ FormalizedDefinition: 
	`Refactoring_FormalizedDefinition' `{'
		 $\textrm{\ding{229}}$ (allDefinition+=BooleanExpression)*
	`}';
BooleanExpression: 
	$\textrm{\ding{183}}$ AndExpression | OrExpression | NotExpression;
AndExpression: 
		$\textrm{\ding{229}}$ `AndExpr' `:' ref1 = Refactoring 
		$\textrm{\ding{229}}$ `&&' ref2 = Refactoring;
OrExpression: 
		$\textrm{\ding{229}}$ `OrExpr' `:' ref1 = Refactoring
		$\textrm{\ding{229}}$ `| |' ref2 = Refactoring ;
NotExpression: 
		$\textrm{\ding{229}}$ `NotExpr' `:' ref = Refactoring;
\end{lstlisting}

A definição da \textit{metaclass} \texttt{FormalizedDefinition} é ilustrada na Listagem de código~\ref{lst:dsl_part_13} \ding{182}. Utilizando as regras ilustradas na Listagem de código~\ref{lst:dsl_part_13} $\textrm{\ding{183}}$ os engenheiros de modernização podem realizar um \textit{chain of primary operations} permitindo a especificar/criar novas refatorações. Por exemplo, é possível criar expressões da seguinte forma, \texttt{createClass \&\& (moveAttribute \&\& createMethod)}.

\subsubsection{Uma notação gráfica (concreta) da DSL para auxiliar a instânciação de refatorações com base no Refac-KDM}

Usualmente os modelos gráficos são mais intuitivos de se utilizar. Assim, com o intuito de prover maior facilidade na instanciação do metamodelo Refac-KDM criou-se uma notação gráfica da DSL. Essa notação gráfica também auxilia o engenheiro de modernização, uma vez que o mesmo não precisa escrever as refatorações utilizando uma linguagem textual, ou seja, apenas elementos gráficos são utilizados para criar e definir as refatorações. Posteriormente, a IDE automaticamente fornece uma sincronização entre a DSL concreta e a DSL textual, provendo assim uma multi-visualização da DSL, gráfica e textual.

A notação gráfica é composta por elementos que permitem a visualização e a edição das informações definidas na DSL de forma gráfica. A construção da sintaxe concreta de uma DSL é dependente da ferramenta adotada para esse fim. Por exemplo, o \textit{Graphical Modeling Framework} (GMF)\footnote{\texttt{https://www.eclipse.org/modeling/gmp/}} utiliza três tipos de modelos para definir a notação gráfica da DSL: (\textit{i}) \textit{Gmfgraph}, (\textit{ii}) \textit{Gmftool} e (\textit{iii}) Gmfmap. Na parte inferior a direita da Figura~\ref{fig:processoDOMETAMODELO} é possível visualizar um exemplo da notação gráfica que foi criada para dar suporte a DSL apresentada na Seção~\ref{sec:DSL}. 

\begin{figure}[h!]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/gmfGraph}}

\caption{Definição da notação gráfica da DSL}
 \label{fig:gmfGraph}
\end{figure}
\FloatBarrier

No modelo \textit{Gmfgraph} são definidos os componentes da notação gráfica da DSL que correspondem às refatorações e seus relacionamentos. Cada componente gráfico pode ser formado pela junção de vários componentes de forma aninhada. Por exemplo, na Figura~\ref{fig:gmfGraph} é mostrado que o conjunto de refatoração relacionado a \textit{rename feature} é representada graficamente por um retângulo (\textit{Rectangle RenameFeatureFigure}) composto de outros retângulos que contêm um rótulo (\textit{RenameFeatureTitle}) e um compartimento (\textit{RenameFeatureCompartment}). Similarmente, a refatoração \textit{rename class} também é representada graficamente por um retângulo (\textit{Rectangle RenameClassFigure}) composto de outros retângulos que contêm um rótulo (\textit{RRenameClassTitle}) e um compartimento (\textit{RRenameClassContent}) que também contêm dois outros rótulos (\textit{RenameClassClassToBeRenamedNameFigure} e (\textit{RenameClassNewNameFigure})). 

No modelo \textit{Gmftool} são definidos os itens de menu dos elementos e dos relacionamentos que podem ser utilizados. Na Figure~\ref{fig:gmfTool} é mostrado o modelo \textit{Gmftool} da DSL, no qual são definidos as refatorações. Note que foi criado um item para cada uma das refatorações: \textit{extract class}, \textit{move attribute}, \textit{move method}, etc.

\begin{figure}[h!]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/gmfTool}}

\caption{Definição dos itens do menu da DSL}
 \label{fig:gmfTool}
\end{figure}
\FloatBarrier


No modelo \textit{Gmfmap} os elementos do metamodelo são combinados com os seus respectivos componentes da notação gráfica e itens de menu. Na Figura~\ref{fig:gmfMap} é ilustrado um exemplo de modelo \textit{Gmfmap} que combina as \textit{metaclasses} e os relacionamentos do metamodelo (Figura~\ref{fig:METAMODELO}) com a notação gráfica definida no modelo \textit{Gmfgraph} (Figura~\ref{fig:gmfGraph}) e com os itens de menu definidos no modelo \textit{Gmftool} (Figura~\ref{fig:gmfTool}). Nesse modelo cada refatoração é definida com a inclusão de um \textit{Top Node Reference} contendo um \textit{Node Mapping}. \textit{Feature Labels} são acrescentados para permitir a visualização e a edição dos nomes e dos tipos das refatorações.


\begin{figure}[h!]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/gmfMap}}

\caption{Modelo \textit{Gmfmap da DSL}}
 \label{fig:gmfMap}
\end{figure}
\FloatBarrier

Na Figuras~\ref{fig:DSLTExtual} e~\ref{fig:DSLGrafica} são mostrados o uso da DSL textual e gráfica para especificar algumas refatorações, respetivamente. É importante destacar que todas as alterações realizadas na DSL textual implica na sincronização automática da DSL gráfica. Da mesma forma, se o engenheiro de software preferir utilizar a notação gráfica para instanciar refatorações a DSL textual também é sincronizada automaticamente. 

\begin{figure}[h!]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/DSLTextual}}
\caption{Exemplo de utilização da DSL textual}
 \label{fig:DSLTExtual}
\end{figure}
\FloatBarrier

\begin{figure}[h!]
 \centering
 \scalebox{0.6}{\includegraphics{figuras/DSLGrafica}}
\caption{Exemplo de utilização da DSL gráfica}
 \label{fig:DSLGrafica}
\end{figure}
\FloatBarrier
